<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ollama Chat Demo</title>
<style>
    html, body {height:100%; margin:0; padding:0; font-family:"Fira Code", "Source Code Pro", Menlo, Monaco, Consolas, "Courier New", monospace; background:#fafafa;}
    body {height:100%;}
    body {display:flex; flex-direction:column; min-height:100%;}
    header {background:#333;color:#fff;padding:1rem; text-align:center;}
    main {flex:1; display:flex; flex-direction:column; padding:1rem; max-width:800px; width:100%; margin:auto; gap:1rem; box-sizing:border-box; overflow:hidden;}
    #controls {display:flex; flex-direction:column; gap:0.5rem;}
    #modelSelect {padding:.5rem;font-size:1rem;width:100%;font-family:inherit;}
    #modelSelect option {font-family:inherit;}
    button {padding:.5rem 1rem;font-size:1rem;}
    #chat {flex:1; border:1px solid #ddd;background:#fff;padding:1rem;overflow:auto; box-sizing:border-box;}
    .msg {margin:.5rem 0; display:flex; gap:.5rem; align-items:flex-start;}
    .msg span.label {font-weight:bold; min-width:6ch; display:inline-block;}
    .msg.user span.label {color:#0066cc;}
    .msg.assistant span.label {color:#d63300;}
    .msg span.content {white-space:pre-wrap;}
    .stats {
        margin-top:0.25rem;
        padding:0.25rem 0.5rem;
        background:#404040;
        color:#f0f0f0;
        font-size:0.875rem;
        border-radius:4px;
    }
    #inputArea {display:flex; gap:0.5rem; align-items:flex-end;}
    #inputBox {flex:1; resize:vertical; min-height:6rem; max-height:12rem; padding:.5rem; font-size:1rem; font-family:inherit; box-sizing:border-box;}
    #sendBtn {align-self:flex-end;}
</style>
</head>
<body>
<header>
    <h1>Ollama Chat</h1>
</header>
<main>
    <div id="controls">
        <select id="modelSelect"></select>
    </div>
    <div id="chat"></div>
    <div id="inputArea">
        <textarea id="inputBox" placeholder="Type your message… (Enter to send, Shift+Enter for newline)"></textarea>
        <button id="sendBtn">Send</button>
    </div>
</main>
<script>
/* ---------- Configuration ---------- */
const OLLAMA_URL = 'http://localhost:11434';   // change if your Ollama instance is elsewhere
const MODEL_STORAGE_KEY = 'ollamaSelectedModel';
const CTX_STORAGE_KEY = 'ollamaModelCtxOverrides';
const numberFormatter = new Intl.NumberFormat();

/* ---------- Utility Functions ---------- */
function appendMessage(sender, text) {
    const chat = document.getElementById('chat');
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('msg', sender);
    const labelSpan = document.createElement('span');
    labelSpan.classList.add('label');
    labelSpan.textContent = sender === 'user' ? 'User :' : 'Agent:';
    const contentSpan = document.createElement('span');
    contentSpan.classList.add('content');
    contentSpan.textContent = ` ${text}`;
    msgDiv.appendChild(labelSpan);
    msgDiv.appendChild(contentSpan);
    chat.appendChild(msgDiv);
    chat.scrollTop = chat.scrollHeight;
    return { msgDiv, contentSpan };
}

function appendStats(statsText) {
    const chat = document.getElementById('chat');
    const statsDiv = document.createElement('div');
    statsDiv.classList.add('stats');
    statsDiv.textContent = statsText;
    chat.appendChild(statsDiv);
    chat.scrollTop = chat.scrollHeight;
}

function formatNumber(value) {
    return typeof value === 'number' && Number.isFinite(value) ? numberFormatter.format(value) : value;
}

/* ---------- State ---------- */
let selectedModel = null;
let conversation = []; // array of {role, content}
let availableModels = [];
let sessionOptions = {};
let currentModelContextLimit = null;
let userSetContext = false;
let ctxOverrides = {};

try {
    const storedOverrides = window.localStorage.getItem(CTX_STORAGE_KEY);
    if (storedOverrides) {
        ctxOverrides = JSON.parse(storedOverrides);
    }
} catch (err) {
    console.warn('Unable to parse stored context overrides:', err);
    ctxOverrides = {};
}

/* ---------- Populate Model List ---------- */
async function loadModels() {
    try {
        const resp = await fetch(`${OLLAMA_URL}/api/tags`);
        if (!resp.ok) throw new Error('Failed to fetch models');
        const data = await resp.json();
        const select = document.getElementById('modelSelect');
        select.innerHTML = '';
        availableModels = [];
        data.models.forEach(m => {
            const opt = document.createElement('option');
            const modelName = m.model || m.name;
            opt.value = modelName;
            opt.textContent = modelName;
            select.appendChild(opt);
            availableModels.push(modelName);
        });
        if (data.models.length > 0) {
            await setDefaultModel(select);
        }
    } catch (err) {
        console.error(err);
        alert('Could not connect to Ollama API. Make sure it is running on ' + OLLAMA_URL);
    }
}

async function setDefaultModel(selectEl) {
    const preference = window.localStorage.getItem(MODEL_STORAGE_KEY);
    if (preference && availableModels.includes(preference)) {
        selectEl.value = preference;
        await handleModelSelection(preference, { preserveHistory: true });
        return;
    }
    try {
        const resp = await fetch(`${OLLAMA_URL}/api/ps`);
        if (!resp.ok) throw new Error('Failed to fetch running models');
        const data = await resp.json();
        const running = data.models && data.models.length > 0 ? (data.models[0].model || data.models[0].name) : null;
        if (running && availableModels.includes(running)) {
            selectEl.value = running;
            await handleModelSelection(running, { preserveHistory: true });
            return;
        }
    } catch (err) {
        console.warn('Could not determine running model:', err);
    }
    const overrideModels = Object.keys(ctxOverrides || {}).filter(model => availableModels.includes(model));
    if (overrideModels.length > 0) {
        const overrideChoice = overrideModels[0];
        selectEl.value = overrideChoice;
        await handleModelSelection(overrideChoice, { preserveHistory: true });
        return;
    }
    if (availableModels.length > 0) {
        const fallback = availableModels[0];
        selectEl.value = fallback;
        await handleModelSelection(fallback, { preserveHistory: true });
    }
}

function labelActiveModel(activeModel) {
    const select = document.getElementById('modelSelect');
    Array.from(select.options).forEach(opt => {
        const baseLabel = opt.value;
        opt.textContent = opt.value === activeModel ? `${baseLabel} (active)` : baseLabel;
    });
}

async function handleModelSelection(model, { preserveHistory = false } = {}) {
    if (!model) return;
    selectedModel = model;
    window.localStorage.setItem(MODEL_STORAGE_KEY, model);
    const select = document.getElementById('modelSelect');
    if (select && select.value !== model) {
        select.value = model;
    }
    labelActiveModel(model);
    if (!preserveHistory) {
        conversation = [];
        const chat = document.getElementById('chat');
        if (chat) {
            chat.innerHTML = '';
        }
    }
    sessionOptions = {};
    userSetContext = false;
    currentModelContextLimit = null;
    if (ctxOverrides[model]) {
        sessionOptions.num_ctx = ctxOverrides[model];
        currentModelContextLimit = ctxOverrides[model];
        userSetContext = true;
    }
    await refreshModelContext(model);
}

async function refreshModelContext(model) {
    if (!model) return;
    try {
        const resp = await fetch(`${OLLAMA_URL}/api/show`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            body: JSON.stringify({ model })
        });
        if (!resp.ok) throw new Error('Failed to fetch model info');
        const info = await resp.json();
        let ctx = null;
        if (typeof info.context_length === 'number') {
            ctx = info.context_length;
        } else if (info.model_info && typeof info.model_info.context_length === 'number') {
            ctx = info.model_info.context_length;
        } else if (typeof info.parameters === 'string') {
            const match = info.parameters.match(/num_ctx\s*=\s*(\d+)/);
            if (match) {
                ctx = parseInt(match[1], 10);
            }
        }
        if (!userSetContext && ctx) {
            sessionOptions.num_ctx = ctx;
        }
        if (!currentModelContextLimit && ctx) {
            currentModelContextLimit = ctx;
        }
    } catch (err) {
        console.warn('Could not load model context information:', err);
    }
}

/* ---------- Send Message ---------- */
async function sendMessage() {
    const input = document.getElementById('inputBox');
    const rawText = input.value;
    if (!rawText.trim()) return;
    const trimmed = rawText.trim();
    if (trimmed.startsWith('/')) {
        const handled = handleSlashCommand(trimmed);
        input.value = '';
        if (!handled) {
            appendStats(`unknown command: ${trimmed}`);
        }
        return;
    }
    appendMessage('user', rawText);
    conversation.push({ role: 'user', content: rawText });
    input.value = '';
    await queryOllama();
}

function handleSlashCommand(command) {
    const args = command.slice(1).trim().split(/\s+/);
    const primary = args[0]?.toLowerCase();
    if (primary === 'set' && args[1]?.toLowerCase() === 'parameter' && args[2]) {
        const param = args[2];
        const value = args[3];
        if (param.toLowerCase() === 'num_ctx' && value) {
            const numeric = parseInt(value, 10);
            if (!Number.isNaN(numeric) && numeric > 0) {
                if (!selectedModel) {
                    appendStats('No model selected to apply num_ctx');
                    return true;
                }
                sessionOptions = { ...sessionOptions, num_ctx: numeric };
                currentModelContextLimit = numeric;
                userSetContext = true;
                ctxOverrides[selectedModel] = numeric;
                try {
                    window.localStorage.setItem(CTX_STORAGE_KEY, JSON.stringify(ctxOverrides));
                } catch (err) {
                    console.warn('Unable to store context override:', err);
                }
                appendStats(`Set parameter 'num_ctx' to '${numeric}'`);
                return true;
            }
            appendStats(`Invalid num_ctx value: ${value}`);
            return true;
        }
        appendStats(`Unsupported parameter: ${param}`);
        return true;
    }
    if (primary === 'clear') {
        conversation = [];
        document.getElementById('chat').innerHTML = '';
        appendStats('Conversation cleared');
        return true;
    }
    return false;
}

/* ---------- Query Ollama ---------- */
async function queryOllama() {
    let placeholder = null;
    let assistantText = '';
    try {
        const start = performance.now();
        const payload = {
            model: selectedModel,
            messages: conversation,
            stream: true
        };
        if (Object.keys(sessionOptions).length > 0) {
            payload.options = { ...sessionOptions };
            if (typeof payload.options.num_ctx === 'number') {
                currentModelContextLimit = payload.options.num_ctx;
            }
        }
        const resp = await fetch(`${OLLAMA_URL}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error('Chat API returned status ' + resp.status);
        if (!resp.body) throw new Error('Streaming not supported in this environment');

        const { contentSpan } = appendMessage('assistant', '');
        placeholder = contentSpan;
        const chat = document.getElementById('chat');
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let finalMeta = {};

        const processLine = line => {
            if (!line) return;
            const normalized = line.startsWith('data:') ? line.slice(5).trim() : line;
            if (!normalized || normalized === '[DONE]') {
                if (normalized === '[DONE]') {
                    finalMeta.done = true;
                }
                return;
            }
            let data;
            try {
                data = JSON.parse(normalized);
            } catch (err) {
                console.warn('Unable to parse stream chunk:', err, normalized);
                return;
            }
            if (data.message && typeof data.message.content === 'string') {
                assistantText += data.message.content;
                contentSpan.textContent = ` ${assistantText}`;
                chat.scrollTop = chat.scrollHeight;
            }
            if (data.options && typeof data.options.num_ctx === 'number') {
                if (!userSetContext) {
                    sessionOptions.num_ctx = data.options.num_ctx;
                }
                currentModelContextLimit = data.options.num_ctx;
            }
            if (data.done) {
                finalMeta = data;
            }
        };

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                processLine(line);
            }
        }
        buffer += decoder.decode();
        const remainder = buffer.trim();
        if (remainder) {
            processLine(remainder);
        }
        const end = performance.now();

        if (finalMeta.error) {
            throw new Error(finalMeta.error);
        }

        if (assistantText) {
            conversation.push({ role: 'assistant', content: assistantText });
        }

        const promptTokens = typeof finalMeta.prompt_eval_count === 'number' ? finalMeta.prompt_eval_count : null;
        const completionTokens = typeof finalMeta.eval_count === 'number' ? finalMeta.eval_count : null;
        const totalTokens = (promptTokens ?? 0) + (completionTokens ?? 0);
        const hasTokenMetrics = promptTokens !== null || completionTokens !== null;
        const durationMs = finalMeta.total_duration ? finalMeta.total_duration / 1_000_000 : (end - start);
        const tokensPerSecondValue = hasTokenMetrics && durationMs > 0 && totalTokens > 0 ? (totalTokens / (durationMs / 1000)) : null;
        const tokensPerSecondLabel = tokensPerSecondValue !== null ? tokensPerSecondValue.toFixed(2) : 'n/a';
        if (finalMeta.options && typeof finalMeta.options.num_ctx === 'number') {
            if (!userSetContext) {
                sessionOptions.num_ctx = finalMeta.options.num_ctx;
            }
            currentModelContextLimit = finalMeta.options.num_ctx;
        }
        const ctxUsed = promptTokens ?? 'n/a';
        const tokensLabel = hasTokenMetrics ? formatNumber(totalTokens) : 'n/a';
        const ctxUsedLabel = typeof ctxUsed === 'number' ? formatNumber(ctxUsed) : ctxUsed;
        const ctxLimitValue = (payload.options && payload.options.num_ctx) ?? sessionOptions.num_ctx ?? currentModelContextLimit ?? 'n/a';
        const ctxLimitLabel = typeof ctxLimitValue === 'number' ? formatNumber(ctxLimitValue) : ctxLimitValue;
        const seconds = durationMs / 1000;
        const statsLine = `time ${seconds.toFixed(3)}s · tokens ${tokensLabel} · ${tokensPerSecondLabel} tok/s · ctx ${ctxUsedLabel}/${ctxLimitLabel}`;
        appendStats(statsLine);
    } catch (err) {
        console.error(err);
        if (placeholder) {
            placeholder.textContent = ` ⛔ Error: ${err.message}`;
        } else {
            appendMessage('assistant', '⛔ Error communicating with Ollama: ' + err.message);
        }
    }
}

/* ---------- Event Listeners ---------- */
document.getElementById('sendBtn').addEventListener('click', sendMessage);
document.getElementById('inputBox').addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});
document.getElementById('modelSelect').addEventListener('change', e => {
    const model = e.target.value;
    handleModelSelection(model).catch(err => console.error('Failed to switch model:', err));
    console.log('Selected model:', model);
});

/* ---------- Initial Load ---------- */
loadModels();
</script>
</body>
</html>
